<!-- nx configuration start-->
<!-- Leave the start & end comments to automatically receive updates. -->

# General Guidelines for working with Nx

- When running tasks (for example build, lint, test, e2e, etc.), always prefer running the task through `nx` (i.e. `nx run`, `nx run-many`, `nx affected`) instead of using the underlying tooling directly
- You have access to the Nx MCP server and its tools, use them to help the user
- When answering questions about the repository, use the `nx_workspace` tool first to gain an understanding of the workspace architecture where applicable.
- When working in individual projects, use the `nx_project_details` mcp tool to analyze and understand the specific project structure and dependencies
- For questions around nx configuration, best practices or if you're unsure, use the `nx_docs` tool to get relevant, up-to-date docs. Always use this instead of assuming things about nx configuration
- If the user needs help with an Nx configuration or project graph error, use the `nx_workspace` tool to get any errors


<!-- nx configuration end-->

# üèóÔ∏è Repository-Specific Instructions

## Overview

This is a **monorepo managed by Nx** containing applications and libraries for TypeScript/NestJS and Go projects. The workspace follows strict quality standards with automated CI/CD, comprehensive testing, and release management.

## Technologies and Stack

### Primary Technologies
- **Nx 20.8.2** - Monorepo build system with task orchestration and caching
- **TypeScript 5.7.2** - Primary language for Node.js projects
- **Go 1.23** - For microservices and libraries
- **NestJS 10.x** - Backend framework for Node.js applications
- **Jest 29.x** - Testing framework for TypeScript/JavaScript
- **pnpm 9.15.0** - Package manager (use pnpm, NOT npm or yarn)

### Code Quality Tools
- **Biome 2.2.6** - Primary linting and formatting tool (preferred over ESLint/Prettier)
- **ESLint 9.x** - Additional linting (use via `nx lint`)
- **SonarQube** - Quality gate integration in CI/CD

## Project Structure

### Applications (`apps/`)
- **`bff-nest`** - Backend for Frontend in NestJS
- **`user-go-service`** - User microservice in Go

### Libraries (`libs/`)
- **`logger-node`** - Modular logging system with correlation IDs, sensitive data redaction, and metrics
- **`utils-nest`** - NestJS utilities (health checks, Swagger, logger adapter)
- **`user-node`** - User domain library for Node.js
- **`user-go`** - User domain library for Go
- **`biome-base`** - Shared Biome configuration

### Tagging System
Projects use tags for categorization:
- `npm:public` - Published to npm registry
- `npm:private` - Internal use only
- `go:public` - Go library versioned via git tags
- `type:app` - Application
- `type:lib` - Library
- `scope:internal` - Internal workspace scope

## Development Commands

### Running Tasks
**ALWAYS use Nx commands** instead of direct tool invocation:

```bash
# Build affected projects
pnpm nx affected -t build

# Test affected projects
pnpm nx affected -t test

# Lint affected projects
pnpm nx affected -t lint

# Format code with Biome
pnpm nx affected -t format

# Run specific project
pnpm nx serve bff-nest
pnpm nx serve user-go-service

# Run all checks (like CI)
pnpm nx ci
```

### Code Quality
```bash
# Format with Biome (preferred)
pnpm nx format

# Check linting (Biome + ESLint)
pnpm nx lint

# Run tests with coverage
pnpm nx affected -t test --coverage
```

## Code Standards

### TypeScript/NestJS
- Use **strict TypeScript** settings - NO `any` types
- Follow **Clean Architecture** principles (domain, application, infrastructure layers)
- Use **dependency injection** via NestJS decorators
- Implement proper **error handling** with custom exceptions
- Add **comprehensive JSDoc comments** for public APIs
- Write **unit tests** using Jest with meaningful test names
- Use **class-validator** and **class-transformer** for DTOs

### Go
- Follow **Go 1.23 standards** and idiomatic Go patterns
- Use **Go modules** for dependency management
- Write **table-driven tests** for comprehensive coverage
- Include **godoc comments** for exported functions/types
- Use **interfaces** for abstraction and testability
- Handle errors explicitly - NO panic in library code

### General Principles
- **SOLID principles** - Single responsibility, dependency inversion, etc.
- **Low coupling, high cohesion** between modules
- **Meaningful naming** - clear, professional, intention-revealing
- **Security by design** - authentication, authorization, least privilege
- **Observability** - structured logs with correlation IDs, metrics, tracing
- **NO hardcoded secrets** - use environment variables or secret managers

## Testing Requirements

### Coverage Expectations
- **Unit tests** - Core business logic (domain layer)
- **Integration tests** - Infrastructure interactions (repositories, external APIs)
- **E2E tests** - Complete user flows (for applications)

### Test Standards
- Use **realistic test data** - avoid generic "test" or "foo/bar" values
- Write **clear assertions** - specific, meaningful error messages
- Test **edge cases** - null values, empty arrays, error conditions
- Ensure **test isolation** - each test should be independent
- **Mock external dependencies** - use Jest mocks or test doubles

## CI/CD and Workflows

### Workflow Architecture
The repository uses **reusable workflow components**:
- `ci.yml` - Main validation orchestrator
- `release.yml` - Manual release workflow
- `release-validation.yml` - Validates release branches
- `_reusable-*` - Shared workflow components (setup, validate, quality-gate, release-steps)

### Before Committing
1. **Run local validation**: `pnpm nx ci`
2. **Format code**: `pnpm nx format`
3. **Fix linting issues**: `pnpm nx affected -t lint --fix`
4. **Verify tests pass**: `pnpm nx affected -t test`
5. **Check builds**: `pnpm nx affected -t build`

### Commit Standards
- Follow **Conventional Commits** (feat, fix, chore, docs, test, refactor, ci, build)
- Keep messages **‚â§ 100 characters**
- Use **clear scope**: `feat(logger-node): add correlation ID support`
- Add **body only when needed** - explain "why" not "what"

## Release Process

### Version Management
- Uses **Nx Release** with independent versioning per project
- Projects tagged with `npm:public` or `go:public` are publishable
- Manual release via GitHub Actions (`release.yml`)

### Release Commands
```bash
# Preview release changes
pnpm nx release --specifier=minor --dry-run

# Create release
pnpm nx release --specifier=minor

# Publish packages
pnpm nx release publish
```

## Important Notes

### What to Do
- **Preserve existing patterns** - follow established code structure
- **Use workspace generators** - create new projects via Nx generators
- **Verify before modifying** - check existing implementations first
- **Update documentation** - keep README and docs in sync with code
- **Test incrementally** - validate changes frequently during development
- **Ask for clarification** - when requirements are ambiguous

### What NOT to Do
- **Don't use npm or yarn** - pnpm is the required package manager
- **Don't bypass Nx** - always use `nx` commands for tasks
- **Don't ignore linting** - Biome and ESLint rules are enforced
- **Don't skip tests** - comprehensive testing is mandatory
- **Don't modify CI workflows** without understanding the architecture
- **Don't commit build artifacts** - dist/, node_modules/, etc. are gitignored
- **Don't introduce breaking changes** without discussing first

## Documentation References

- [NX Generators Guide](docs/NX_GENERATORS.md) - Creating new projects
- [Release Process](docs/RELEASE_PROCESS.md) - Version management and publishing
- [Workflows Architecture](docs/WORKFLOWS_ARCHITECTURE.md) - CI/CD design and components

---

# üìò Global Engineering Communication & Execution Rules

## Vis√£o Geral

Estas regras consolidam diretrizes de **comunica√ß√£o, engenharia, execu√ß√£o e qualidade t√©cnica**, aplic√°veis a todos os fluxos de trabalho, automa√ß√µes, revis√µes e intera√ß√µes com reposit√≥rios, c√≥digo ou pipelines.

---

## ‚úÖ Se√ß√µes Principais

### ‚úÖ DEVE

**Princ√≠pios de Comunica√ß√£o e Pensamento**

* Usar `context7` para manter rastreabilidade decis√£o ‚Üí a√ß√£o ‚Üí resultado.
* Aplicar pensamento sequencial: cada etapa deve derivar logicamente da anterior.
* Responder em portugu√™s t√©cnico e formal, com completude, consist√™ncia e clareza.
* Ser objetivo e direto ‚Äî garantindo autossufici√™ncia e coer√™ncia contextual.
* Explicitar depend√™ncias, vers√µes, limita√ß√µes e decis√µes ‚Äî n√£o assumir por infer√™ncia.
* Verificar scripts e workflows existentes antes de criar novos.
* Consultar hist√≥rico Git para entender o contexto funcional antes de modificar c√≥digo ou automa√ß√µes.
* Fazer an√°lise minuciosa, detalhista e pragm√°tica em cada revis√£o.
* Remover configura√ß√µes √≥rf√£s, tempor√°rias ou obsoletas ap√≥s mudan√ßas.
* Validar que arquivos e caminhos referenciados existem ‚Äî evitando refer√™ncias quebradas.
* Aplicar SOLID, baixo acoplamento, alta coes√£o e Clean Architecture.
* Usar nomenclatura significativa e consistente, preferindo nomes profissionais e diretos.
* Comunicar limita√ß√µes e incertezas t√©cnicas ‚Äî evitando afirma√ß√µes absolutas sem verifica√ß√£o emp√≠rica.
* Ser cauteloso com afirma√ß√µes de certeza ‚Äî qualificando o grau de confian√ßa e a base de evid√™ncia.
* Atualizar status e progresso de forma transparente ‚Äî permitindo visibilidade de riscos e pend√™ncias.
* Manter o usu√°rio no controle das decis√µes importantes, oferecendo contexto, alternativas e recomenda√ß√µes.
* Fazer apenas o que √© solicitado, sem extrapolar o escopo.
* Validar antes de aplicar mudan√ßas ‚Äî planejamento, testes e impacto.
* Ser cuidadoso e preciso no trabalho, nas an√°lises e implementa√ß√µes.

### ‚ö†Ô∏è Governan√ßa e Manuten√ß√£o Documental

* Revisar periodicamente as documenta√ß√µes t√©cnicas para garantir consist√™ncia, atualidade e alinhamento com padr√µes vigentes.
* Validar se novas bibliotecas, m√≥dulos ou frameworks adotados seguem os padr√µes t√©cnicos e de arquitetura estabelecidos.
* Atualizar documenta√ß√µes sempre que houver mudan√ßas significativas em fluxos, depend√™ncias, decis√µes ou padr√µes.
* Manter foco tecnol√≥gico em cada documenta√ß√£o espec√≠fica ‚Äî evitando dilui√ß√£o conceitual ou mistura de contextos entre tecnologias.
* Garantir rastreabilidade entre o conte√∫do documentado e sua implementa√ß√£o real (reposit√≥rios, ADRs, RFCs, diagramas e automa√ß√µes).
* Estabelecer revis√µes peri√≥dicas de consist√™ncia cruzada entre os n√≠veis C4 (Context, Container, Component e Code).
* Promover aprendizado organizacional ‚Äî cada revis√£o documental deve contribuir para o amadurecimento t√©cnico coletivo.

### ‚ùå N√ÉO DEVE

* Pressupor que algo n√£o existe sem verifica√ß√£o expl√≠cita.
* Executar opera√ß√µes Git sem permiss√£o expressa do usu√°rio ‚Äî toda a√ß√£o de push, merge ou rebase deve ser confirmada.
* Modificar c√≥digo, workflows ou configura√ß√µes n√£o solicitadas.
* Reescrever quando basta corrigir ‚Äî foco em ‚Äúcorrigir, n√£o reescrever‚Äù.
* Ignorar valida√ß√µes pr√©vias (exist√™ncia de arquivos, refer√™ncias de workflows, checks CI/CD).
* Usar `any` em TypeScript, expor segredos ou quebrar isolamento de contexto.
* Violar controle do usu√°rio sobre o reposit√≥rio (push for√ßado, branch override).
* Criar arquivos ou artefatos desnecess√°rios ‚Äî evitar ru√≠do e d√≠vida operacional.

### üß© C√≥digo e Qualidade T√©cnica

* Entregar c√≥digo completo e funcional, sem placeholders ou lacunas de implementa√ß√£o.
* Comentar brevemente cada bloco cr√≠tico, explicando prop√≥sito e l√≥gica local.
* Respeitar arquitetura limpa ‚Äî separa√ß√£o clara entre dom√≠nio, aplica√ß√£o e infraestrutura.
* Incluir testes unit√°rios, de integra√ß√£o e e2e com dados realistas e asserts claros.
* Testar mais extensivamente antes de declarar ‚Äúpronto‚Äù ‚Äî incluir cen√°rios de erro e condi√ß√µes-limite.
* Executar revis√µes t√©cnicas com foco em reprodutibilidade e robustez.
* Garantir testabilidade e observabilidade em cada m√≥dulo (logs estruturados, tracing, m√©tricas com `correlation-id` e `tenant`).
* Aplicar seguran√ßa por design ‚Äî autentica√ß√£o, autoriza√ß√£o e princ√≠pio do menor privil√©gio.
* Evitar anti-padr√µes (segredos hardcoded, logs sens√≠veis, depend√™ncias n√£o rastreadas).

### üß† Estilo e Objetividade na Comunica√ß√£o

* Respostas devem ser completas e autossuficientes, sem depender de contexto externo.
* Explicitar claramente hip√≥teses quando infer√™ncias forem necess√°rias.
* Separar fatos de suposi√ß√µes ‚Äî marcar hip√≥teses explicitamente.
* Usar estrutura organizada, t√≥picos claros e terminologia t√©cnica precisa.
* Ser conservador nas a√ß√µes ‚Äî realizar o m√≠nimo necess√°rio para resolver o problema.
* Perguntar antes de agir, especialmente para opera√ß√µes destrutivas ou automatizadas.
* Atualizar status de forma transparente ‚Äî comunicar progresso e limita√ß√µes.

### üßæ Commits e Controle de Vers√£o

* Seguir Conventional Commits (‚â§ 100 caracteres, escopo claro).
* Incluir body apenas quando necess√°rio, descrevendo racioc√≠nio t√©cnico e impactos.
* Manter consist√™ncia sem√¢ntica: feat, fix, refactor, chore, test, docs, build, ci.
* Evitar commits ruidosos ‚Äî cada mudan√ßa deve ter um prop√≥sito t√©cnico justific√°vel.

### üîç Testabilidade, Observabilidade e Seguran√ßa

* Cobertura de testes: unit√°rios (core), integra√ß√£o (infra) e e2e (fluxo completo).
* Observabilidade: logs estruturados, tracing, m√©tricas e correla√ß√£o.
* Seguran√ßa: autentica√ß√£o, autoriza√ß√£o, criptografia e segrega√ß√£o de privil√©gios.
* Nunca armazenar segredos no c√≥digo ou nos logs.
* Identificar gaps de monitoramento e documentar limita√ß√µes.

### üß≠ Tr√™s Caminhos Pr√°ticos de A√ß√£o

#### ‚úÖ Reformular Pergunta

* ‚ÄúVoc√™ quer que eu apenas valide e liste ajustes m√≠nimos sem aplicar mudan√ßas diretas?‚Äù
* ‚ÄúDeseja que eu corrija apenas o erro X, mantendo o restante inalterado e criando PR, n√£o push?‚Äù

#### ‚ö†Ô∏è Explorar Hip√≥teses

* Hip√≥teses: redund√¢ncia de workflows, configura√ß√µes obsoletas, hist√≥rico inconsistente.
* Riscos: regress√µes em CI/CD, perda de hist√≥rico, depend√™ncias ocultas.
* Mitiga√ß√µes: valida√ß√£o incremental, dry-run, aprova√ß√£o em PR.

#### ‚úÖ Confirmar Opera√ß√£o

* Sempre solicitar permiss√£o antes de opera√ß√µes Git.
* Procurar exist√™ncia real de scripts/workflows, hist√≥rico Git, refer√™ncias e segredos.
* Termos de busca: `uses:`, `path:.github/workflows/`, `Ref not found`, `deprecated`.
* Fontes: hist√≥rico Git, logs CI, CODEOWNERS, pol√≠ticas de branch.
* Limita√ß√£o: sem acesso direto, conclus√µes s√£o **hip√≥teses**.

---

## üí¨ S√≠ntese Filos√≥fica

> ‚ÄúMenos √© mais.‚Äù ‚Äî Corrigir, n√£o reescrever.
> ‚ÄúO usu√°rio decide.‚Äù ‚Äî Permiss√£o expl√≠cita antes de Git.
> ‚ÄúPrever √© testar.‚Äù ‚Äî Declara√ß√£o de pronto requer evid√™ncia.
> ‚ÄúTranspar√™ncia constr√≥i confian√ßa.‚Äù ‚Äî Limita√ß√µes e progresso devem ser vis√≠veis.
