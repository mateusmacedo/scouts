name: CI Quality Gate

on:
  # Triggers diretos para main e develop
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]
  workflow_dispatch:
    inputs:
      stress_test_project:
        description: 'Projeto para executar testes de stress (ex: @scouts/logger-node)'
        required: true
        type: string
        default: '@scouts/logger-node'

jobs:
  quality-check:
    name: Quality Check
    runs-on: ubuntu-latest
    timeout-minutes: 20

    steps:
      - name: Checkout code
        uses: actions/checkout@v5
        with:
          fetch-depth: 0
          filter: tree:0
          fetch-tags: true

      - name: Generate Correlation ID
        id: correlation-id
        run: echo "CORRELATION_ID=$(uuidgen)" >> $GITHUB_ENV

      - name: Validate CI/CD Secrets
        id: validate-secrets
        env:
          GL_TOKEN: ${{ secrets.GL_TOKEN }}
          NPM_TOKEN: ${{ secrets.NPM_TOKEN }}
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
        run: bash scripts/security/validate-secrets.sh

      - name: Run CI Environment Health Checks
        id: health-check
        continue-on-error: true # NÃ£o bloquear pipeline, apenas alertar
        env:
          SONARQUBE_HOST: https://sonarcloud.io
        run: bash scripts/utils/health-check-ci.sh

      - name: Check for Go changes
        id: go-changes
        run: |
          if [ -f "apps/user-go-service/go.sum" ] || [ -f "libs/user-go/go.sum" ] || 
             git diff --name-only HEAD~1 HEAD | grep -E "(apps/user-go-service|libs/user-go|go\.sum|go\.mod)" > /dev/null 2>&1; then
            echo "has_go_changes=true" >> $GITHUB_OUTPUT
            echo "âœ… MudanÃ§as Go detectadas"
          else
            echo "has_go_changes=false" >> $GITHUB_OUTPUT
            echo "â„¹ï¸ Nenhuma mudanÃ§a Go detectada"
          fi

      - name: Setup Node.js and pnpm
        uses: ./.github/actions/setup-node-pnpm
        id: node-pnpm-setup
        env:
          NODE_AUTH_TOKEN: ${{ secrets.GL_TOKEN }}

      - name: Setup Go
        uses: ./.github/actions/setup-go
        with:
          has-go-changes: ${{ steps.go-changes.outputs.has_go_changes }}
        id: go-setup

      - name: Restore Nx cache
        uses: ./.github/actions/restore-nx-cache
        id: nx-cache

      - name: Setup Playwright (Background)
        run: |
          echo "ğŸ­ Iniciando setup do Playwright em background..."
          # Usar job groups para permitir wait funcionar corretamente
          set -m
          bash scripts/utils/setup-playwright-background.sh &
          PLAYWRIGHT_PID=$!
          echo "PLAYWRIGHT_SETUP_PID=$PLAYWRIGHT_PID" >> $GITHUB_ENV
          echo "âœ… Setup do Playwright iniciado em background (PID: $PLAYWRIGHT_PID)"

      - name: Set base reference for affected calculations
        id: base-ref
        run: |
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            echo "base_ref=origin/${{ github.base_ref }}" >> $GITHUB_OUTPUT
          else
            # For push events, use the previous commit
            echo "base_ref=HEAD~1" >> $GITHUB_OUTPUT
          fi

      - name: Show affected projects
        run: |
          echo "ğŸ“Š Projetos afetados:"
          pnpm nx show projects --affected --base=${{ steps.base-ref.outputs.base_ref }}

      - name: Quality Checks
        run: |
          echo "ğŸ” Executando verificaÃ§Ãµes de qualidade em paralelo..."

          timeout 300 pnpm nx affected --target=lint --base=${{ steps.base-ref.outputs.base_ref }} --parallel=3 &
          LINT_PID=$!

          timeout 300 pnpm nx affected --target=format --base=${{ steps.base-ref.outputs.base_ref }} --parallel=3 &
          FORMAT_PID=$!

          timeout 300 pnpm nx affected --target=typecheck --base=${{ steps.base-ref.outputs.base_ref }} --parallel=3 &
          TYPE_PID=$!

          timeout 300 pnpm nx affected --target=build --base=${{ steps.base-ref.outputs.base_ref }} --parallel=3 &
          BUILD_PID=$!

          wait $LINT_PID
          wait $FORMAT_PID
          wait $TYPE_PID
          wait $BUILD_PID

          echo "âœ… VerificaÃ§Ãµes de qualidade concluÃ­das"

      - name: Wait for Playwright Setup
        run: |
          echo "â³ Aguardando conclusÃ£o do setup do Playwright..."
          if [ -n "$PLAYWRIGHT_SETUP_PID" ]; then
            # Verificar se o processo ainda estÃ¡ rodando
            if kill -0 $PLAYWRIGHT_SETUP_PID 2>/dev/null; then
              echo "ğŸ”„ Processo Playwright ainda rodando (PID: $PLAYWRIGHT_SETUP_PID)"
              # Usar job groups para permitir wait funcionar corretamente
              set -m
              wait $PLAYWRIGHT_SETUP_PID && echo "âœ… Setup do Playwright concluÃ­do com sucesso" || echo "âš ï¸ Setup do Playwright falhou, continuando"
            else
              echo "âœ… Processo Playwright jÃ¡ finalizou"
            fi
          else
            echo "â„¹ï¸ Setup do Playwright nÃ£o foi iniciado"
          fi

      - name: Set base reference for affected calculations
        id: base-ref-e2e
        run: |
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            echo "base_ref=origin/${{ github.base_ref }}" >> $GITHUB_ENV
            echo "head_ref=${{ github.head_ref }}" >> $GITHUB_ENV
          else
            echo "base_ref=HEAD~1" >> $GITHUB_ENV
            echo "head_ref=HEAD" >> $GITHUB_ENV
          fi
      
      - name: Identify Affected E2E Projects
        id: affected-e2e
        run: |
          echo "ğŸ“Š Identificando projetos E2E afetados..."
          AFFECTED_E2E_PROJECTS=$(node scripts/tests/get-affected-e2e.js)
          echo "AFFECTED_E2E_PROJECTS=${AFFECTED_E2E_PROJECTS}" >> $GITHUB_OUTPUT
          echo "Projetos E2E a serem testados: ${AFFECTED_E2E_PROJECTS}"

      - name: Run E2E Tests and Tests with Coverage (Parallel)
        run: |
          echo "ğŸ§ª Executando testes E2E e testes com coverage em paralelo..."
          
          # Configurar variÃ¡veis de ambiente para Playwright
          export PLAYWRIGHT_SKIP_BROWSER_DOWNLOAD=1
          export PLAYWRIGHT_BROWSERS_PATH=~/.cache/ms-playwright
          
          # Executar testes E2E em background (usando a lista de projetos afetados)
          echo "ğŸŒ Iniciando testes E2E..."
          AFFECTED_E2E="${{ steps.affected-e2e.outputs.AFFECTED_E2E_PROJECTS }}"
          if [ -n "$AFFECTED_E2E" ] && [ "$AFFECTED_E2E" != "[]" ]; then
            PROJECT_LIST=$(echo "$AFFECTED_E2E" | jq -r '. | join(",")')
            echo "Executando testes para: $PROJECT_LIST"
            timeout 1200 pnpm nx run-many --target=e2e --projects="$PROJECT_LIST" --parallel=2 &
            E2E_PID=$!
          else
            echo "â„¹ï¸ Nenhum projeto E2E afetado. Pulando testes E2E."
            E2E_PID=""
          fi
          
          # Executar testes TypeScript/JavaScript com coverage em background
          # Usar estratÃ©gia otimizada baseada no contexto
          echo "ğŸ“Š Iniciando testes TypeScript/JavaScript com coverage..."
          timeout 600 bash scripts/coverage-strategy.sh "affected" ${{ steps.base-ref.outputs.base_ref }} 3 &
          TS_TEST_PID=$!
          
          # Executar testes Go com coverage em background
          echo "ğŸ”§ Iniciando testes Go com coverage..."
          bash scripts/generate-go-coverage.sh &
          GO_TEST_PID=$!
          
          # Aguardar conclusÃ£o de todos os testes
          echo "â³ Aguardando conclusÃ£o de todos os testes..."
          if [ -n "$E2E_PID" ]; then wait $E2E_PID; fi
          wait $TS_TEST_PID
          wait $GO_TEST_PID
          
          echo "âœ… Todos os testes concluÃ­dos (E2E + TypeScript/JavaScript + Go)"

      - name: Build and Prepare Coverage (Parallel)
        run: |
          echo "ğŸš€ Executando build e preparaÃ§Ã£o de coverage em paralelo..."
          
          # Build em background
          (
            echo "ğŸ—ï¸ Iniciando builds..."
            timeout 300 pnpm nx affected --target=build --base=${{ steps.base-ref.outputs.base_ref }} --parallel=3
            
            echo "ğŸ” Validando build artifacts..."
            if [ "$(find . -name "dist" -type d | wc -l)" -gt 0 ]; then
              echo "âœ… Build artifacts encontrados:"
              find . -name "dist" -type d | head -5
            else
              echo "âš ï¸ Nenhum build artifact encontrado"
            fi
          ) &
          BUILD_PID=$!
          
          # Coverage preparation em background
          (
            echo "ğŸ“Š Preparando e consolidando relatÃ³rios de coverage..."
            
            # Criar diretÃ³rios de coverage se nÃ£o existirem
            mkdir -p coverage
            
            # Executar consolidaÃ§Ã£o de JS/TS e Go em paralelo
            (
                echo "ğŸ”§ Consolidando coverage de JS/TS..."
                node scripts/consolidate-coverage.js
            ) &
            JS_COVERAGE_PID=$!

            (
                echo "ğŸ”§ Consolidando coverage de Go..."
                bash scripts/generate-go-coverage.sh
            ) &
            GO_COVERAGE_PID=$!

            wait $JS_COVERAGE_PID
            wait $GO_COVERAGE_PID

            # Verificar se existem arquivos de coverage consolidados
            if [ -f "coverage/consolidated/consolidated.info" ] || [ -f "coverage/go/go-coverage.out" ]; then
                echo "âœ… Arquivos de coverage consolidados encontrados."
                # ... (lÃ³gica de limpeza pode ser movida para os scripts individuais)
            else
                echo "â„¹ï¸ Nenhum arquivo de coverage encontrado - criando placeholder"
                echo "No coverage data available" > coverage/placeholder.txt
            fi
          ) &
          COVERAGE_PID=$!
          
          # Aguardar ambos
          echo "â³ Aguardando conclusÃ£o de build e coverage preparation..."
          wait $BUILD_PID
          wait $COVERAGE_PID
          
          echo "âœ… Build e coverage preparation concluÃ­dos em paralelo"

      - name: Upload Build Artifacts
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: build-artifacts-${{ github.run_id }}
          path: |
            dist/
            **/dist/
            build/
            **/build/
          retention-days: 1
          if-no-files-found: warn

      - name: Upload Coverage Reports
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: coverage-reports-${{ github.run_id }}
          path: |
            coverage/
            **/coverage/
            reports/
          retention-days: 1
          if-no-files-found: warn

      - name: Set Quality Status
        id: quality-status
        if: always()
        run: |
          if [ "${{ job.status }}" = "success" ]; then
            echo "status=success" >> $GITHUB_OUTPUT
            echo "âœ… Quality Gate: SUCCESS"
          else
            echo "status=failure" >> $GITHUB_OUTPUT
            echo "âŒ Quality Gate: FAILURE"
          fi

      - name: Set Coverage Status
        id: coverage-status
        if: always()
        run: |
          if [ "$(find . -name "*.lcov" -o -name "lcov.info" -o -name "coverage.xml" | wc -l)" -gt 0 ]; then
            echo "available=true" >> $GITHUB_OUTPUT
            echo "âœ… Coverage: AVAILABLE"
          else
            echo "available=false" >> $GITHUB_OUTPUT
            echo "âŒ Coverage: NOT AVAILABLE"
          fi

      - name: Cache Performance Metrics
        if: always()
        run: |
          echo "ğŸ“Š MÃ©tricas de Cache:"
          echo "  - pnpm cache: ${{ steps.node-pnpm-setup.outputs.cache-hit }}"
          echo "  - Go cache: ${{ steps.go-setup.outputs.cache-hit }}"
          echo "  - Nx cache: ${{ steps.nx-cache.outputs.cache-hit }}"

      - name: Quality Gate Summary
        if: always()
        run: |
          echo "ğŸ‰ Quality Gate concluÃ­do!"
          echo "ğŸ“Š Status: ${{ steps.quality-status.outputs.status }}"
          echo "ğŸ“Š Coverage: ${{ steps.coverage-status.outputs.available }}"
          echo "ğŸ“Š VerificaÃ§Ãµes executadas:"
          echo "  âœ… Lint Check (TypeScript/JavaScript + Go)"
          echo "  âœ… Format Check (TypeScript/JavaScript + Go)"
          echo "  âœ… Type Check (TypeScript)"
          echo "  âœ… Go Build Check"
          echo "  âœ… Tests (TypeScript/JavaScript + Go)"
          echo "  âœ… E2E Tests"
          echo "  âœ… Coverage Reports"
          echo "  âœ… Build Projects"
          echo "ğŸ“ RelatÃ³rios de coverage salvos como artefatos"

  sonar-analysis:
    name: SonarCloud Analysis
    runs-on: ubuntu-latest
    needs: quality-check
    if: always() && needs.quality-check.result == 'success'
    timeout-minutes: 20  # Aumentado para permitir anÃ¡lise completa do SonarCloud

    steps:
      - name: Checkout code
        uses: actions/checkout@v5
        with:
          fetch-depth: 0
          filter: tree:0
          fetch-tags: true

      - name: Setup Node.js and pnpm
        uses: ./.github/actions/setup-node-pnpm
        id: node-pnpm-setup
        env:
          NODE_AUTH_TOKEN: ${{ secrets.GL_TOKEN }}

      - name: Download Coverage Reports
        uses: actions/download-artifact@v4
        with:
          name: coverage-reports-${{ github.run_id }}
          path: .
        continue-on-error: true
        id: download-coverage

      - name: Check Coverage Reports Availability
        run: |
          if [ "${{ steps.download-coverage.outcome }}" = "success" ]; then
            echo "âœ… Coverage reports baixados com sucesso"
            echo "ğŸ“ Arquivos de coverage encontrados:"
            find . -name "*.lcov" -o -name "lcov.info" -o -name "coverage.xml" | head -10 || echo "Nenhum arquivo de coverage encontrado"
          else
            echo "âš ï¸ Coverage reports nÃ£o disponÃ­veis - executando testes para gerar coverage"
            echo "ğŸ’¡ Isso pode acontecer se o job quality-check nÃ£o gerou coverage ou falhou"
          fi

      - name: Setup Playwright (conditional)
        uses: ./.github/actions/setup-playwright
        if: steps.download-coverage.outcome != 'success'
        with:
          install-browsers: 'false'
        id: playwright-setup

      - name: Setup Go (conditional for fallback)
        uses: ./.github/actions/setup-go
        if: steps.download-coverage.outcome != 'success'
        with:
          has-go-changes: 'true'
        id: go-setup-fallback

      - name: Generate Coverage Reports (if missing)
        if: steps.download-coverage.outcome != 'success'
        run: |
          echo "ğŸ§ª Executando testes para TODOS os projetos (fallback completo)..."
          echo "ğŸ’¡ Executando todos os projetos para garantir coverage completo no SonarCloud"
          echo "ğŸ“ NOTA: Usamos --all (nÃ£o --affected) para garantir coverage completo quando quality-check falhou"
          
          # Executar testes unitÃ¡rios com coverage para TODOS os projetos
          echo "ğŸ“Š Executando testes unitÃ¡rios com coverage para todos os projetos..."
          pnpm nx run-many --target=test --all --parallel=3 --coverage
          
          # Executar testes de integraÃ§Ã£o se disponÃ­veis para TODOS os projetos
          echo "ğŸ”— Executando testes de integraÃ§Ã£o com coverage para todos os projetos..."
          pnpm nx run-many --target=test:integration --all --parallel=2 || echo "â„¹ï¸ Nenhum teste de integraÃ§Ã£o encontrado"
          
          # Executar testes E2E se disponÃ­veis para TODOS os projetos
          echo "ğŸŒ Executando testes E2E com coverage para todos os projetos..."
          pnpm nx run-many --target=e2e --all --parallel=2 || echo "â„¹ï¸ Nenhum teste E2E encontrado"
          
          # Verificar se coverage foi gerado
          if find . -name "*.lcov" -o -name "lcov.info" -o -name "coverage.xml" | head -1 | grep -q .; then
            echo "âœ… Coverage reports gerados com sucesso para todos os projetos"
            find . -name "*.lcov" -o -name "lcov.info" -o -name "coverage.xml" | head -10
            echo "ğŸ“Š Total de arquivos de coverage gerados:"
            find . -name "*.lcov" -o -name "lcov.info" -o -name "coverage.xml" | wc -l
          else
            echo "âš ï¸ Nenhum coverage report foi gerado pelos testes"
          fi

      - name: Set base reference for affected calculations
        id: base-ref
        run: |
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            echo "base_ref=origin/${{ github.base_ref }}" >> $GITHUB_OUTPUT
          else
            # For push events, use the previous commit
            echo "base_ref=HEAD~1" >> $GITHUB_OUTPUT
          fi

      - name: Validate Coverage Reports
        run: |
          echo "ğŸ” Validando relatÃ³rios de coverage disponÃ­veis..."
          if find . -name "*.lcov" -o -name "lcov.info" -o -name "coverage.xml" | head -1 | grep -q .; then
            echo "âœ… Coverage reports encontrados e validados"
            find . -name "*.lcov" -o -name "lcov.info" -o -name "coverage.xml" | head -10
            echo "ğŸ“Š Total de arquivos de coverage:"
            find . -name "*.lcov" -o -name "lcov.info" -o -name "coverage.xml" | wc -l
          else
            echo "âš ï¸ Coverage reports nÃ£o encontrados - continuando anÃ¡lise sem coverage"
            echo "ğŸ’¡ SonarCloud serÃ¡ executado sem dados de coverage"
          fi

      - name: Validate Coverage Paths for SonarCloud
        run: |
          echo "ğŸ” Validando paths de coverage para SonarCloud..."
          
          # Verificar arquivos LCOV (TypeScript/JavaScript)
          echo "ğŸ“Š Arquivos LCOV encontrados:"
          find . -name "lcov.info" -o -name "*.lcov" | grep -v node_modules | head -20 || echo "Nenhum arquivo LCOV encontrado"
          
          # Verificar arquivos Go
          echo "ğŸ“Š Arquivos Go coverage encontrados:"
          find coverage/go -name "*.out" 2>/dev/null | head -10 || echo "Nenhum arquivo Go coverage encontrado"
          
          # Verificar arquivo consolidado
          if [ -f "coverage/consolidated/consolidated.info" ]; then
            echo "âœ… Coverage consolidado encontrado"
            echo "ğŸ“ Tamanho: $(wc -l < coverage/consolidated/consolidated.info) linhas"
          else
            echo "âš ï¸ Coverage consolidado nÃ£o encontrado"
          fi
          
          # Listar estrutura de diretÃ³rios de coverage
          echo "ğŸ“ Estrutura de coverage:"
          tree -L 3 coverage/ 2>/dev/null || find coverage/ -type f | head -20

      - name: Consolidate coverage reports (if not already done)
        run: |
          echo "ğŸ“Š Verificando se coverage jÃ¡ foi consolidado..."
          
          # Verificar se coverage consolidado jÃ¡ existe (do quality-check)
          if [ -f coverage/consolidated/consolidated.info ]; then
            echo "âœ… Coverage jÃ¡ consolidado pelo quality-check: coverage/consolidated/consolidated.info"
          elif find . -name "*.lcov" -o -name "lcov.info" -o -name "coverage.xml" | head -1 | grep -q .; then
            echo "âœ… Arquivos de coverage encontrados, consolidando..."
            
            # Usar script Node.js simples e confiÃ¡vel
            if [ -f scripts/consolidate-coverage.js ]; then
              echo "ğŸ”§ Executando scripts/consolidate-coverage.js..."
              node scripts/consolidate-coverage.js
              
              # Verificar se consolidaÃ§Ã£o foi bem-sucedida
              if [ -f coverage/consolidated/consolidated.info ]; then
                echo "âœ… Coverage consolidado com sucesso: coverage/consolidated/consolidated.info"
                
                # Executar limpeza de arquivos individuais
                if [ -f scripts/cleanup-coverage.js ]; then
                  echo "ğŸ§¹ Executando limpeza de arquivos individuais..."
                  node scripts/cleanup-coverage.js
                  echo "âœ… Limpeza de coverage concluÃ­da"
                else
                  echo "âš ï¸ Script de limpeza nÃ£o encontrado"
                fi
              else
                echo "âš ï¸ Coverage nÃ£o foi consolidado corretamente"
              fi
            else
              echo "âš ï¸ scripts/consolidate-coverage.js nÃ£o encontrado"
            fi
          else
            echo "â„¹ï¸ Nenhum arquivo de coverage encontrado para consolidar"
          fi

      - name: Cache Trivy Database
        uses: actions/cache@v4
        with:
          path: .trivycache
          key: trivy-db-v1-${{ runner.os }}
          restore-keys: |
            trivy-db-v1-${{ runner.os }}

      - name: Generate Dependency Security Reports
        run: |
          echo "ğŸ” Gerando relatÃ³rios de seguranÃ§a com Trivy..."
          mkdir -p reports
          # Garantir permissÃµes de escrita no diretÃ³rio de relatÃ³rios mesmo apÃ³s execuÃ§Ã£o do Docker
          chmod -R a+rwx reports || true

          # Cache do Trivy persistente
          export TRIVY_CACHE_DIR="$PWD/.trivycache"
          mkdir -p "$TRIVY_CACHE_DIR" && chmod -R a+rwx "$TRIVY_CACHE_DIR" || true

          echo "ğŸ” Trivy: Analisando vulnerabilidades..."
          timeout 60 docker run --rm --user "$(id -u):$(id -g)" -e TRIVY_CACHE_DIR="/workspace/.trivycache" -v "$(pwd)":/workspace -w /workspace \
            ghcr.io/aquasecurity/trivy:latest fs --scanners vuln --format json --output reports/trivy-report.json . || {
            echo "âš ï¸ Trivy falhou, criando relatÃ³rio vazio"
            echo '[]' > reports/trivy-report.json
          }

          echo "ğŸ“„ Trivy: Gerando relatÃ³rio HTML..."
          timeout 60 docker run --rm --user "$(id -u):$(id -g)" -e TRIVY_CACHE_DIR="/workspace/.trivycache" -v "$(pwd)":/workspace -w /workspace \
            ghcr.io/aquasecurity/trivy:latest fs --scanners vuln --format table --output reports/trivy-report.txt . || {
            echo "âš ï¸ Trivy table falhou, criando relatÃ³rio bÃ¡sico"
            echo "No vulnerabilities found or analysis failed." > reports/trivy-report.txt
          }

          # Criar relatÃ³rio HTML bÃ¡sico
          echo "ğŸ“„ Criando relatÃ³rio HTML bÃ¡sico..."
          cat > reports/trivy-report.html << 'EOF'
          <html>
          <head>
            <title>Trivy Security Report</title>
            <style>
              body { font-family: Arial, sans-serif; margin: 20px; }
              pre { background: #f5f5f5; padding: 10px; border-radius: 5px; overflow-x: auto; }
              h1 { color: #333; }
              .success { color: #28a745; }
              .warning { color: #ffc107; }
              .error { color: #dc3545; }
            </style>
          </head>
          <body>
            <h1>Trivy Security Report</h1>
            <p>Generated by Trivy via CI/CD workflow</p>
            <div class="success">âœ… Security scan completed successfully</div>
            <p>No vulnerabilities found or analysis completed.</p>
          </body>
          </html>
          EOF

          echo "ğŸ“Š Criando relatÃ³rios para SonarCloud..."

          if [ -f "reports/trivy-report.html" ]; then
            cp reports/trivy-report.html reports/dependency-check-report.html
            echo "âœ… RelatÃ³rio HTML do Trivy copiado para SonarCloud"
          else
            echo '<html><head><title>Dependency Security Report</title></head><body>' > reports/dependency-check-report.html
            echo '<h1>Dependency Security Report</h1>' >> reports/dependency-check-report.html
            echo '<p>Generated by Trivy via CI/CD workflow</p>' >> reports/dependency-check-report.html
            echo '<p>No vulnerabilities found or analysis failed.</p>' >> reports/dependency-check-report.html
            echo '</body></html>' >> reports/dependency-check-report.html
          fi

          echo "ğŸ“Š Processando dados do Trivy JSON para SonarCloud..."

          TOTAL_VULNS=0
          HIGH_SEVERITY=0
          MEDIUM_SEVERITY=0
          LOW_SEVERITY=0

          if [ -f "reports/trivy-report.json" ]; then
            TOTAL_VULNS=$(jq -r '[.[] | .Vulnerabilities // [] | length] | add // 0' reports/trivy-report.json 2>/dev/null || echo "0")
            HIGH_SEVERITY=$(jq -r '[.[] | .Vulnerabilities // [] | .[] | select(.Severity == "HIGH")] | length // 0' reports/trivy-report.json 2>/dev/null || echo "0")
            MEDIUM_SEVERITY=$(jq -r '[.[] | .Vulnerabilities // [] | .[] | select(.Severity == "MEDIUM")] | length // 0' reports/trivy-report.json 2>/dev/null || echo "0")
            LOW_SEVERITY=$(jq -r '[.[] | .Vulnerabilities // [] | .[] | select(.Severity == "LOW")] | length // 0' reports/trivy-report.json 2>/dev/null || echo "0")
          fi

          cat > reports/dependency-check-report.json << EOF
          {
            "report": {
              "generated": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
              "tools": ["trivy"],
              "summary": {
                "total_vulnerabilities": $TOTAL_VULNS,
                "high_severity": $HIGH_SEVERITY,
                "medium_severity": $MEDIUM_SEVERITY,
                "low_severity": $LOW_SEVERITY
              },
              "note": "Vulnerability analysis performed by Trivy container using official JSON format"
            }
          }
          EOF

          echo "âœ… RelatÃ³rios de dependency check criados com dados oficiais do Trivy para SonarCloud"
          echo "ğŸ“Š Vulnerabilidades encontradas: $TOTAL_VULNS (High: $HIGH_SEVERITY, Medium: $MEDIUM_SEVERITY, Low: $LOW_SEVERITY)"

      - name: SonarCloud Analysis
        timeout-minutes: 10
        env:
          GL_TOKEN: ${{ secrets.GL_TOKEN }}
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
          SONAR_PROJECT_KEY: ${{ secrets.SONAR_PROJECT_KEY }}
          SONAR_ORGANIZATION: ${{ secrets.SONAR_ORGANIZATION }}
        run: |
          echo "ğŸ” Executando anÃ¡lise SonarCloud..."

          # Escolher entre anÃ¡lise completa ou incremental
          # Para branches 'main' e 'develop', executa a anÃ¡lise completa.
          # Para outros eventos (como PRs), executa a anÃ¡lise incremental.
          if [[ "${{ github.ref }}" == "refs/heads/main" || "${{ github.ref }}" == "refs/heads/develop" ]]; then
              echo "ğŸš€ Executando anÃ¡lise completa do SonarCloud..."
              # Comando de anÃ¡lise completa com todas as configuraÃ§Ãµes necessÃ¡rias
              # Calcular timeouts baseado no tamanho do projeto
              FILE_COUNT=$(find . -name "*.ts" -o -name "*.tsx" -o -name "*.js" -o -name "*.jsx" -o -name "*.go" | grep -v node_modules | wc -l)
              if [ "$FILE_COUNT" -gt 1000 ]; then
                TIMEOUT_WS=300
                TIMEOUT_SCANNER=300000
              elif [ "$FILE_COUNT" -gt 500 ]; then
                TIMEOUT_WS=200
                TIMEOUT_SCANNER=200000
              else
                TIMEOUT_WS=120
                TIMEOUT_SCANNER=120000
              fi
              echo "ğŸ“Š Projeto com $FILE_COUNT arquivos - usando timeouts: WS=${TIMEOUT_WS}s, Scanner=${TIMEOUT_SCANNER}ms"
              
              # Usar arquivos individuais de coverage para otimizar performance
              echo "ğŸ” Buscando arquivos individuais de coverage para otimizar performance..."
              INDIVIDUAL_FILES=$(find . -name "lcov.info" -o -name "*.lcov" | grep -v node_modules | tr '\n' ',' | sed 's/,$//')
              if [ -n "$INDIVIDUAL_FILES" ]; then
                COVERAGE_PATH="$INDIVIDUAL_FILES"
                echo "âœ… Usando arquivos individuais de coverage (otimizado): $COVERAGE_PATH"
                echo "ğŸ’¡ Arquivos individuais sÃ£o mais eficientes que consolidado"
              else
                echo "âš ï¸ Nenhum arquivo de coverage encontrado"
                COVERAGE_PATH=""
              fi
              
              # Construir comando SonarCloud com coverage se disponÃ­vel
              SONAR_COMMAND="npx sonar-scanner \
                -Dsonar.projectKey=\"\$SONAR_PROJECT_KEY\" \
                -Dsonar.organization=\"\$SONAR_ORGANIZATION\" \
                -Dsonar.host.url=\"https://sonarcloud.io\" \
                -Dsonar.token=\"\$SONAR_TOKEN\" \
                -Dsonar.sources=apps,libs \
                -Dsonar.exclusions=\"**/node_modules/**,**/dist/**,**/*.spec.ts,**/*.test.ts\" \
                -Dsonar.dependencyCheck.htmlReportPath=reports/dependency-check-report.html \
                -Dsonar.dependencyCheck.jsonReportPath=reports/dependency-check-report.json \
                -Dsonar.log.level=WARN \
                -Dsonar.qualitygate.wait=false \
                -Dsonar.scm.disabled=true"
              
              # Adicionar coverage paths se disponÃ­veis
              if [ -n "$COVERAGE_PATH" ]; then
                SONAR_COMMAND="$SONAR_COMMAND -Dsonar.javascript.lcov.reportPaths=$COVERAGE_PATH -Dsonar.typescript.lcov.reportPaths=$COVERAGE_PATH"
                echo "âœ… Coverage configurado para SonarCloud: $COVERAGE_PATH"
                
                # Debug: verificar conteÃºdo do coverage
                if [ -f "$COVERAGE_PATH" ]; then
                  echo "ğŸ“Š Debug - Coverage file info:"
                  echo "  ğŸ“ Tamanho: $(wc -l < "$COVERAGE_PATH") linhas"
                  echo "  ğŸ“„ Primeiras linhas:"
                  head -5 "$COVERAGE_PATH"
                  echo "  ğŸ“„ Ãšltimas linhas:"
                  tail -5 "$COVERAGE_PATH"
                else
                  echo "âŒ Coverage file nÃ£o encontrado: $COVERAGE_PATH"
                fi
              else
                echo "âš ï¸ Executando anÃ¡lise SonarCloud sem dados de coverage"
              fi
              # Executar com retry e tratamento de erro especÃ­fico
              echo "ğŸš€ Executando anÃ¡lise SonarCloud com Quality Gate desabilitado..."
              echo "ğŸ’¡ Quality Gate desabilitado temporariamente para debug"
              
              if bash scripts/utils/retry-with-backoff.sh 3 15 "$SONAR_COMMAND"; then
                echo "âœ… AnÃ¡lise SonarCloud concluÃ­da com sucesso"
                echo "ğŸ“Š AnÃ¡lise completada - Quality Gate foi desabilitado para debug"
                echo "ğŸ’¡ Para reativar Quality Gate, altere -Dsonar.qualitygate.wait=true"
              else
                echo "âŒ AnÃ¡lise SonarCloud falhou apÃ³s 3 tentativas"
                echo "ğŸ” Verificando logs de erro..."
                echo "ğŸ’¡ PossÃ­veis causas:"
                echo "  - Timeout de rede ou servidor SonarCloud"
                echo "  - Problemas de autenticaÃ§Ã£o (verificar SONAR_TOKEN)"
                echo "  - Problemas de conectividade (verificar sonarcloud.io)"
                echo "  - Arquivos de coverage corrompidos"
                exit 1
              fi
          else
              echo "âš¡ï¸ Executando anÃ¡lise incremental do SonarCloud..."
              bash scripts/sonar/incremental-analysis.sh
          fi

      - name: Cleanup Coverage Files
        if: always()
        run: |
          echo "ğŸ§¹ Limpando arquivos de coverage apÃ³s anÃ¡lise SonarCloud..."
          
          # Executar limpeza de arquivos individuais
          if [ -f scripts/cleanup-coverage.js ]; then
            echo "ğŸ”§ Executando limpeza de arquivos individuais..."
            node scripts/cleanup-coverage.js
            echo "âœ… Limpeza de coverage concluÃ­da"
          else
            echo "âš ï¸ Script de limpeza nÃ£o encontrado"
          fi

      - name: SonarCloud Summary
        if: always()
        run: |
          echo "ğŸ‰ AnÃ¡lise SonarCloud concluÃ­da!"
          echo "ğŸ“Š AnÃ¡lises executadas:"
          if find . -name "*.lcov" -o -name "lcov.info" -o -name "coverage.xml" | head -1 | grep -q .; then
            if [ "${{ steps.download-coverage.outcome }}" = "success" ]; then
              echo "  âœ… Coverage Reports (baixados do job anterior)"
            else
              echo "  âœ… Coverage Reports (gerados localmente)"
            fi
          else
            echo "  âš ï¸ Coverage Reports (nÃ£o disponÃ­vel)"
          fi
          echo "  âœ… Security Analysis (Trivy)"
          echo "  âœ… SonarCloud Analysis"

  stress-tests:
    name: Stress Tests
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch'
    timeout-minutes: 10

    steps:
      - name: Checkout code
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: Setup Node.js and pnpm
        uses: ./.github/actions/setup-node-pnpm
        id: node-pnpm-setup
        env:
          NODE_AUTH_TOKEN: ${{ secrets.GL_TOKEN }}

      - name: List Available Stress Test Projects
        run: |
          echo "ğŸ” Projetos disponÃ­veis com testes de stress:"
          pnpm nx show projects --with-target=test:stress || echo "â„¹ï¸ Nenhum projeto com target 'test:stress' encontrado"
          echo ""
          echo "ğŸ“‹ Projetos conhecidos que podem ter testes de stress:"
          echo "  - @scouts/logger-node"
          echo "  - (outros projetos serÃ£o adicionados conforme necessÃ¡rio)"

      - name: Validate Selected Project
        run: |
          PROJECT="${{ github.event.inputs.stress_test_project }}"
          echo "ğŸ¯ Projeto selecionado: $PROJECT"
          
          # Verificar se o projeto existe
          if ! pnpm nx show project "$PROJECT" > /dev/null 2>&1; then
            echo "âŒ Projeto '$PROJECT' nÃ£o encontrado no workspace"
            echo "ğŸ’¡ Projetos disponÃ­veis:"
            pnpm nx show projects
            exit 1
          fi
          
          # Verificar se o projeto tem target test:stress
          if ! pnpm nx show project "$PROJECT" --json | jq -e '.targets["test:stress"]' > /dev/null 2>&1; then
            echo "âŒ Projeto '$PROJECT' nÃ£o possui target 'test:stress'"
            echo "ğŸ’¡ Targets disponÃ­veis para '$PROJECT':"
            pnpm nx show project "$PROJECT" --json | jq -r '.targets | keys[]' | sort
            exit 1
          fi
          
          echo "âœ… Projeto '$PROJECT' validado com sucesso"

      - name: Run Stress Tests
        run: |
          PROJECT="${{ github.event.inputs.stress_test_project }}"
          echo "ğŸ”¥ Executando testes de stress do projeto: $PROJECT"
          echo "â±ï¸ Tempo estimado: 20-30 segundos"
          pnpm nx test:stress "$PROJECT"
          echo "âœ… Testes de stress concluÃ­dos com sucesso!"

      - name: Stress Test Summary
        if: always()
        run: |
          PROJECT="${{ github.event.inputs.stress_test_project }}"
          echo "ğŸ‰ Testes de stress concluÃ­dos!"
          echo "ğŸ“Š Projeto testado: $PROJECT"
          echo "ğŸ“Š Volume testado: ~5000 logs/hora"
          echo "â±ï¸ Tempo de execuÃ§Ã£o: ~20-30 segundos"
