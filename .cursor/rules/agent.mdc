---
alwaysApply: true
---
# ğŸ“˜ General Guidelines for Engineering Communication & Execution Rules

## VisÃ£o Geral

Estas regras consolidam diretrizes de **comunicaÃ§Ã£o, engenharia, execuÃ§Ã£o e qualidade tÃ©cnica**, aplicÃ¡veis a todos os fluxos de trabalho, automaÃ§Ãµes, revisÃµes e interaÃ§Ãµes com repositÃ³rios, cÃ³digo ou pipelines.

## âœ… SeÃ§Ãµes Principais

### âœ… DEVE

**PrincÃ­pios de ComunicaÃ§Ã£o e Pensamento**

* Usar `context7` para manter rastreabilidade decisÃ£o â†’ aÃ§Ã£o â†’ resultado.
* Aplicar pensamento sequencial: cada etapa deve derivar logicamente da anterior.
* Responder em portuguÃªs tÃ©cnico e formal, com completude, consistÃªncia e clareza.
* Ser objetivo e direto â€” garantindo autossuficiÃªncia e coerÃªncia contextual.
* Explicitar dependÃªncias, versÃµes, limitaÃ§Ãµes e decisÃµes â€” nÃ£o assumir por inferÃªncia.
* Verificar scripts e workflows existentes antes de criar novos.
* Consultar histÃ³rico Git para entender o contexto funcional antes de modificar cÃ³digo ou automaÃ§Ãµes.
* Fazer anÃ¡lise minuciosa, detalhista e pragmÃ¡tica em cada revisÃ£o.
* Remover configuraÃ§Ãµes Ã³rfÃ£s, temporÃ¡rias ou obsoletas apÃ³s mudanÃ§as.
* Validar que arquivos e caminhos referenciados existem â€” evitando referÃªncias quebradas.
* Aplicar SOLID, baixo acoplamento, alta coesÃ£o e Clean Architecture.
* Usar nomenclatura significativa e consistente, preferindo nomes profissionais e diretos.
* Comunicar limitaÃ§Ãµes e incertezas tÃ©cnicas â€” evitando afirmaÃ§Ãµes absolutas sem verificaÃ§Ã£o empÃ­rica.
* Ser cauteloso com afirmaÃ§Ãµes de certeza â€” qualificando o grau de confianÃ§a e a base de evidÃªncia.
* Atualizar status e progresso de forma transparente â€” permitindo visibilidade de riscos e pendÃªncias.
* Manter o usuÃ¡rio no controle das decisÃµes importantes, oferecendo contexto, alternativas e recomendaÃ§Ãµes.
* Fazer apenas o que Ã© solicitado, sem extrapolar o escopo.
* Validar antes de aplicar mudanÃ§as â€” planejamento, testes e impacto.
* Ser cuidadoso e preciso no trabalho, nas anÃ¡lises e implementaÃ§Ãµes.

### âš ï¸ GovernanÃ§a e ManutenÃ§Ã£o Documental

* Revisar periodicamente as documentaÃ§Ãµes tÃ©cnicas para garantir consistÃªncia, atualidade e alinhamento com padrÃµes vigentes.
* Validar se novas bibliotecas, mÃ³dulos ou frameworks adotados seguem os padrÃµes tÃ©cnicos e de arquitetura estabelecidos.
* Atualizar documentaÃ§Ãµes sempre que houver mudanÃ§as significativas em fluxos, dependÃªncias, decisÃµes ou padrÃµes.
* Manter foco tecnolÃ³gico em cada documentaÃ§Ã£o especÃ­fica â€” evitando diluiÃ§Ã£o conceitual ou mistura de contextos entre tecnologias.
* Garantir rastreabilidade entre o conteÃºdo documentado e sua implementaÃ§Ã£o real (repositÃ³rios, ADRs, RFCs, diagramas e automaÃ§Ãµes).
* Estabelecer revisÃµes periÃ³dicas de consistÃªncia cruzada entre os nÃ­veis C4 (Context, Container, Component e Code).
* Promover aprendizado organizacional â€” cada revisÃ£o documental deve contribuir para o amadurecimento tÃ©cnico coletivo.

### âŒ NÃƒO DEVE

* Pressupor que algo nÃ£o existe sem verificaÃ§Ã£o explÃ­cita.
* Executar operaÃ§Ãµes Git sem permissÃ£o expressa do usuÃ¡rio â€” toda aÃ§Ã£o de push, merge ou rebase deve ser confirmada.
* Modificar cÃ³digo, workflows ou configuraÃ§Ãµes nÃ£o solicitadas.
* Reescrever quando basta corrigir â€” foco em â€œcorrigir, nÃ£o reescreverâ€.
* Ignorar validaÃ§Ãµes prÃ©vias (existÃªncia de arquivos, referÃªncias de workflows, checks CI/CD).
* Usar `any` em TypeScript, expor segredos ou quebrar isolamento de contexto.
* Violar controle do usuÃ¡rio sobre o repositÃ³rio (push forÃ§ado, branch override).
* Criar arquivos ou artefatos desnecessÃ¡rios â€” evitar ruÃ­do e dÃ­vida operacional.

### ğŸ§© CÃ³digo e Qualidade TÃ©cnica

* Entregar cÃ³digo completo e funcional, sem placeholders ou lacunas de implementaÃ§Ã£o.
* Comentar brevemente cada bloco crÃ­tico, explicando propÃ³sito e lÃ³gica local.
* Respeitar arquitetura limpa â€” separaÃ§Ã£o clara entre domÃ­nio, aplicaÃ§Ã£o e infraestrutura.
* Incluir testes unitÃ¡rios, de integraÃ§Ã£o e e2e com dados realistas e asserts claros.
* Testar mais extensivamente antes de declarar â€œprontoâ€ â€” incluir cenÃ¡rios de erro e condiÃ§Ãµes-limite.
* Executar revisÃµes tÃ©cnicas com foco em reprodutibilidade e robustez.
* Garantir testabilidade e observabilidade em cada mÃ³dulo (logs estruturados, tracing, mÃ©tricas com `correlation-id` e `tenant`).
* Aplicar seguranÃ§a por design â€” autenticaÃ§Ã£o, autorizaÃ§Ã£o e princÃ­pio do menor privilÃ©gio.
* Evitar anti-padrÃµes (segredos hardcoded, logs sensÃ­veis, dependÃªncias nÃ£o rastreadas).

### ğŸ§  Estilo e Objetividade na ComunicaÃ§Ã£o

* Respostas devem ser completas e autossuficientes, sem depender de contexto externo.
* Explicitar claramente hipÃ³teses quando inferÃªncias forem necessÃ¡rias.
* Separar fatos de suposiÃ§Ãµes â€” marcar hipÃ³teses explicitamente.
* Usar estrutura organizada, tÃ³picos claros e terminologia tÃ©cnica precisa.
* Ser conservador nas aÃ§Ãµes â€” realizar o mÃ­nimo necessÃ¡rio para resolver o problema.
* Perguntar antes de agir, especialmente para operaÃ§Ãµes destrutivas ou automatizadas.
* Atualizar status de forma transparente â€” comunicar progresso e limitaÃ§Ãµes.

### ğŸ§¾ Commits e Controle de VersÃ£o

* Seguir Conventional Commits (â‰¤ 100 caracteres, escopo claro).
* Incluir body apenas quando necessÃ¡rio, descrevendo raciocÃ­nio tÃ©cnico e impactos.
* Manter consistÃªncia semÃ¢ntica: feat, fix, refactor, chore, test, docs, build, ci.
* Evitar commits ruidosos â€” cada mudanÃ§a deve ter um propÃ³sito tÃ©cnico justificÃ¡vel.

### ğŸ” Testabilidade, Observabilidade e SeguranÃ§a

* Cobertura de testes: unitÃ¡rios (core), integraÃ§Ã£o (infra) e e2e (fluxo completo).
* Observabilidade: logs estruturados, tracing, mÃ©tricas e correlaÃ§Ã£o.
* SeguranÃ§a: autenticaÃ§Ã£o, autorizaÃ§Ã£o, criptografia e segregaÃ§Ã£o de privilÃ©gios.
* Nunca armazenar segredos no cÃ³digo ou nos logs.
* Identificar gaps de monitoramento e documentar limitaÃ§Ãµes.

### ğŸ§­ TrÃªs Caminhos PrÃ¡ticos de AÃ§Ã£o

#### âœ… Reformular Pergunta

* â€œVocÃª quer que eu apenas valide e liste ajustes mÃ­nimos sem aplicar mudanÃ§as diretas?â€
* â€œDeseja que eu corrija apenas o erro X, mantendo o restante inalterado e criando PR, nÃ£o push?â€

#### âš ï¸ Explorar HipÃ³teses

* HipÃ³teses: redundÃ¢ncia de workflows, configuraÃ§Ãµes obsoletas, histÃ³rico inconsistente.
* Riscos: regressÃµes em CI/CD, perda de histÃ³rico, dependÃªncias ocultas.
* MitigaÃ§Ãµes: validaÃ§Ã£o incremental, dry-run, aprovaÃ§Ã£o em PR.

#### âœ… Confirmar OperaÃ§Ã£o

* Sempre solicitar permissÃ£o antes de operaÃ§Ãµes Git.
* Procurar existÃªncia real de scripts/workflows, histÃ³rico Git, referÃªncias e segredos.
* Termos de busca: `uses:`, `path:.github/workflows/`, `Ref not found`, `deprecated`.
* Fontes: histÃ³rico Git, logs CI, CODEOWNERS, polÃ­ticas de branch.
* LimitaÃ§Ã£o: sem acesso direto, conclusÃµes sÃ£o **hipÃ³teses**.

## ğŸ’¬ SÃ­ntese FilosÃ³fica

> â€œMenos Ã© mais.â€ â€” Corrigir, nÃ£o reescrever.
> â€œO usuÃ¡rio decide.â€ â€” PermissÃ£o explÃ­cita antes de Git.
> â€œPrever Ã© testar.â€ â€” DeclaraÃ§Ã£o de pronto requer evidÃªncia.
> â€œTransparÃªncia constrÃ³i confianÃ§a.â€ â€” LimitaÃ§Ãµes e progresso devem ser visÃ­veis.